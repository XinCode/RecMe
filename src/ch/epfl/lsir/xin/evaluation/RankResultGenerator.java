//Copyright (C) 2014  Xin Liu
//
//RecMe: a lightweight recommendation algorithm library
//
//RecMe is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

/**
 * This class implements ranking based result generator for the given recommendation algorithm
 * 
 *  @author Xin Liu
 * */

package ch.epfl.lsir.xin.evaluation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;

import ch.epfl.lsir.xin.datatype.RatingMatrix;
import ch.epfl.lsir.xin.model.NumericRating;
import ch.epfl.lsir.xin.model.User;

public class RankResultGenerator {

	/**
	 * the results generated by a recommendation algorithm (for each user index)
	 * */
	private HashMap<Integer , ArrayList<ResultUnit>> results = null;
	
	/**
	 * test rating matrix
	 * */
	private RatingMatrix testRatingMatrix = null;
	
	/**
	 * top N recommendation
	 * */
	private int TopN = -1;
	
	/**
	 * logger of the system
	 * */
	private Logger logger = Logger.getLogger(RankResultGenerator.class);
	
	/**
	 * constructor
	 * @param: the input results
	 * @param: top-N setting
	 * */
	public RankResultGenerator( HashMap<Integer , ArrayList<ResultUnit>> results , 
			int topN , RatingMatrix testRatingMatrix )
	{
		this.results = results;
		this.TopN = topN;
		this.testRatingMatrix = testRatingMatrix;
	}
	
	/**
	 * This function generates the precision@N
	 * @return: the calculated precision@N
	 * */
	public double getPrecisionN()
	{
		double precision = 0;
		int count = 0;
		for( Map.Entry<Integer, ArrayList<ResultUnit>> entry : this.results.entrySet() )
		{
			int userIndex = entry.getKey();
			ArrayList<ResultUnit> res = entry.getValue();//recommended items
			int hit = 0;
			for( int i = 0 ; i < res.size() ; i++ )
			{
				if( this.testRatingMatrix.getRatingMatrix().get(userIndex).keySet().contains(res.get(i).getItemIndex()) )
				{
					hit++;
				}
			}
			precision = precision + (double)hit/this.TopN;
			count++;
		}
		if( count > 0 )
		{
			return precision/count;
		}else{
			logger.info("RankResultGenerator: Cannot generate precision@N");
			return Double.NaN;
		}
	}
	
	/**
	 * This function generates recall@N
	 * @return: the calculated recall@N
	 * */
	public double getRecallN()
	{
		double recall = 0;
		int count = 0;
		for( Map.Entry<Integer, ArrayList<ResultUnit>> entry : this.results.entrySet() )
		{
			int userIndex = entry.getKey();
			ArrayList<ResultUnit> res = entry.getValue();
			int hit = 0;
			int total = this.testRatingMatrix.getUserRatingNumber(userIndex);
			if( total == 0 )//this user is ignored
				continue;

			for( int i = 0 ; i < res.size() ; i++ )
			{
				if( this.testRatingMatrix.getRatingMatrix().get(userIndex).keySet().contains(res.get(i).getItemIndex()) )
				{
					hit++;
				}
			}
			recall = recall + (double)hit/total;
			count++;
		}
		if( count > 0 )
		{
			return recall/count;
		}else{
			logger.info("RankResultGenerator: Cannot generate recall@N");
			return Double.NaN;
		}
	}
	
	/**
	 * This function generates MAP@N
	 * @return: the calculated MAP@N
	 * */
	public double getMAPN()
	{
		double map = 0;
		int count = 0;
		for( Map.Entry<Integer, ArrayList<ResultUnit>> entry : this.results.entrySet() )
		{
			int userIndex = entry.getKey();
			ArrayList<ResultUnit> res = entry.getValue();
			int hit = 0;
			double ap = 0;
			for( int i = 0 ; i < res.size() ; i++ )
			{
				if( this.testRatingMatrix.getRatingMatrix().get(userIndex).keySet().contains(res.get(i).getItemIndex()) )
				{
					hit++;
				}
				ap = ap + hit/(i+1);
			}
			if( hit > 0 )//only the recommendation at this position is counted
			{
				map = map + ap/hit;
			}
			count++;
		}
		if( count > 0 )
		{
			return map/count;
		}else{
			logger.info("RankResultGenerator: Cannot generate MAP@N");
			return Double.NaN;
		}
	}
	
	/**
	 * This function generates MRR@N
	 * @return: the calculated MRR@N
	 * */
	public double getMRRN()
	{
		double mrr = 0;
		int count = 0;
		for( Map.Entry<Integer, ArrayList<ResultUnit>> entry : this.results.entrySet() )
		{
			int userIndex = entry.getKey();
			ArrayList<ResultUnit> res = entry.getValue();
			int first = 0;
			for( int i = 0 ; i < res.size() ; i++ )
			{
				if( this.testRatingMatrix.getRatingMatrix().get(userIndex).keySet().contains(res.get(i).getItemIndex()) )
				{
					first = i + 1;
				}
				
				if( first > 0 )
					break;
			}
			if( first > 0 )
			{
				mrr = mrr + (double)1/first;
			}
			count++;
		}
		if( count > 0 )
		{
			return mrr/count;
		}else{
			logger.info("RankResultGenerator: Cannot generate MRR@N");
			return Double.NaN;
		}
	}
	
	/**
	 * This function generates NDCG@N
	 * @return: calculated NDCG@N
	 * */
	public double getNDCGN()
	{
		double ndcg = 0;
		int count = 0;		
		for( Map.Entry<Integer, ArrayList<ResultUnit>> entry : this.results.entrySet() )
		{
			int userIndex = entry.getKey();
			ArrayList<ResultUnit> res = entry.getValue();
			double dcg = 0;
			int c = 0;
			for( int i = 0 ; i < res.size() ; i++ )
			{
				if( this.testRatingMatrix.getRatingMatrix().get(userIndex).keySet().contains(res.get(i).getItemIndex()) )
				{
					dcg = dcg +  Math.log(2) / Math.log(i + 2);
					c++;
				}
				
			}
			if( c > 0 )//number of positive/predicted items
			{
				double idcg = getIDCG( c );
				ndcg = ndcg + dcg/idcg;
			}
			count++;
		}
		if( count > 0 )
		{
			return ndcg/count;
		}else{
			logger.info("RankResultGenerator: Cannot generate NDCG@N");
			return Double.NaN;
		}
	}
	
	/**
	 * This function computes the ideal DCG (iDCG)
	 * @param: the number of positive items
	 * @return: calculated IDCG
	 * */
	public double getIDCG( int n )
	{
		double idcg = 0;
		for( int i = 0 ; i < n ; i++ )
		{
			idcg = idcg + Math.log(2) / Math.log(i + 2);
		}
		return idcg;
	}
	
	/**
	 * This function generates the Area Under Curve (AUC)
	 * @return: the calculated AUC
	 * */
	public double getAUC()
	{
		double auc = 0;
		int count = 0;
		
		for( Map.Entry<Integer, ArrayList<ResultUnit>> entry : this.results.entrySet() )
		{
			int userIndex = entry.getKey();
			ArrayList<ResultUnit> res = entry.getValue();
			int all_pairs = 0; int correct_pairs = 0;
			int hit = 0;//number of successfully predicted items
			int nHit = 0;//number of predicted items that do not hit
			int relevantUnder = 0;//number of relevant items that are not predicted
			for( int i = 0 ; i < res.size() ; i++ )
			{
				boolean h = false;//does this recommendation hit??
				if( this.testRatingMatrix.getRatingMatrix().get(userIndex).keySet().contains(res.get(i).getItemIndex()) )
				{
					h = true;
				}
				if( h )
				{
					hit++;
				}else
				{	
					//correct pairs for (hit item vs. items after this hit item in the rec list)
					correct_pairs = correct_pairs + hit;		
					nHit++;
				}
				
			}
			relevantUnder = this.testRatingMatrix.getUserRatingNumber(userIndex) - hit;
			all_pairs = (nHit + relevantUnder) * hit;//negative * positive
			correct_pairs = correct_pairs + hit * relevantUnder;
			if( all_pairs == 0 )
			{
				auc = auc + 0.5;
			}else{
				double u_auc = (double)correct_pairs/all_pairs; 
				auc = auc + u_auc;
			}			
			count++;
		}
		
		if( count > 0 )
		{
			return auc/count;
		}else{
			logger.info("RankResultGenerator: Cannot generate AUC@N");
			return Double.NaN;
		}
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
